> Это ещё не окончательный вариант работы. 
Буду доделывать коммиты(прибираться в файлах, структурировать, что то переделывать). 
Выложила, потому как боялась закрытия регистрации. 
Просьба по окончанию проверки - оповестить. amelchenko_t.m@mail.ru

## Перед прочтением "Процесса решения" 

В процессе решения старалась подробно описать основные действия, 
как мыслила и как пришла к тому или иному выводу + могут встречаться некоторые отступления и догадки. 

### Процесс решение

Сначала я хотела установить шаблонизатор ejs, потому как он был максимально прибллижен к html. 
Почитав отзывы и сравнения между jade и ejs - лучше было начать привыкать к jade, 
так как у него были преимущества (минимизация, документация, не надо доставлять что то ещё для наследования шаблонов).
Позже я слышала ещё про Реакт - но решила, пока остановиться на jade. 

>Прим. Синтаксис как в jade - не встречала. 
(с шаблонизатором Smarty давно только работала в codeigniter(php-фреймворк) )
Но через некоторое время работы и чтения документации - стало привычно. 

При установке jade - я узнала что он был переименован в pug. В итоге получается, что
шаблонизатор , используемый в приложении будет pug =) 

Понравился из задания бэкэнда - semistandard - который проверяет стиль кода. 
Поэтому в эту часть проекта - тоже его добавила. 

Поначалу было тяжело понять, как лучше организовать одностраничное приложения. 
Думала - может какие специальные модули есть, и какая то ообенная логика. Поначалу соединяла 
бэкенд и фронтэнд в один проект

>Прим. Просто работала с php-фреймворком yii - по принципу MVC - модель-отображение-контроллер. 
И мне эта структура нравилась, поскольку легко можно было найти что и где. 

Но потом наткнулась на пример приложения 
[Single-Page-App-with-REST-API](https://github.com/Microsoft/Windows-tutorials-web/tree/master/Single-Page-App-with-REST-API) 
И решила взять за основу. 
Идея - совсем разделить фронэнд от бэкэнда - понравилась. Поэтому решила делать по такому же типу. 

Устанавливаем сервер, который будет слушать 80 порт - поэтому к нему можно будет просто обращаться 
по http://localhost
Шаблоны в папке views. Подгружаем шапку страницы(layout) и к ней будем подключать блоки остальных страниц.

>Прим. Было бы много страничное приложение - использовали бы наследование.

Подключаем библиотеку jquery - считаю, что на ней намного удобней писать, чем на чистом js. 

> Прим.Старалась максимально не использовать фреймворки, но без неё тяжело

#### Приступим к "оживлению" страницы.

Для отображения нужного блока страницы будем использовать функицю 
**showPage (page)**
page - имя передаваемой страницы. 

Для удобства переключения - задала всем блокам с контентом страниц - идентификаторы начинающиеся с **"page-"**, 
чтобы удобнее скрывать было остальные и показывать нужные. 

Будем выносить глобальные переменные в начало скрипта, как своеобразный конфиг. 
При показа страницы редактирования и новой страницы - будем использовать один и тотже блок
`\#page-edit-meet` , просто будем пользоваться глобальным объектом `currMeet` - если он будет заполнен, 
то будем заполнять поля в блоке, а нет - считать новой встречей. 

Чтобы не писать длинную большую ф-ию вынесем в отдельную функцию процесс обработки блока `page-edit-meet`. 
Функция - **initEditPage ()**

Для обозначения какого либо действия - будем использовать аттрибут data-*. 
Ну и напишем обрабочик. 

>Прим. Также будем использовать и для хранения значений aтрибут data-*. Но из jquery будем обращаться к нему 
напрямую. через метод .attr() - поскольку он кэшируется, если через .data()

C помощью функции - **genQueryToStorage()** - будем создавать шаблоны для запросов к graphql. 
Как составлять запросы читала [тут](http://graphql.org/learn/queries/). 

>Лучше всего запросы к graphql сначала создать через веб интерфейс. 

Функцией - updateBlocks - собиралась обновлять списки, получив информацию с бэкэнда. 
Списки - участников, заполнение таблицы с занятым временем.
Список рекомендаций - но пока не всё - реализовано. 

####Мучения с выпадающим списком участников: #####
> Прим. Этот абзац был написан первым, сначала я думала расписать вкратце процесс решение, 
но потом захотелось поделиться процессом. 
Ну и также, он для того, чтобы напоминать себе - что не всё так просто - как кажется. 

Казалось, простая задача : 
***при фокусе на элементе input.input-participant для ввода участников - показывать выпадающий список, а при потере фокуса или выборе участника - скрывать***. 

Но тут возникла проблема: ***когда мы кликаем на один из пунктов выпадающего списка
то событие клика не успевает отработать, потому что событие потери фокуса наступает раньше.***

Сначала пыталась добавить проверку(кликнули по выпадающему списку или кликнули на другой элемент) 
в событие простого клика по документу. 

> Прим. Вариант такого решения мне не очень нравится, 
потому что по любому клику на документе будут происходить операции сравнивания документа. 
А если таких элементов будет много, то будет большой список проверок. 

Показывать `div.select-participant-wrap`, когда `input.input-participant`
в фокусе(посредством css), мне нравился и не было желания его убирать.
И я решила добавить ещё один вариант показа, когда он имеет псевдокласс hover. 

Однако, появился баг, что при клике на нужный  элемент в списке, 
он остается также с псевдоклассом hover и продолжает показываться(так как мышка после клика находится на этом элементе).
Поэтому решила добавить ему класс .no-hover - при котором он не будет показываться. 
Однако, нужно его как то снимать... 
И тут можно было привязаться к событию фокуса на нужном input, чтобы снимать класс.

> Прим. Может и стоило подключить jquery-ui - для выпадающего списка, календаря и т.д. 
И заниматься больше разработкой, но хотелось попробовать самостоятельно дописать. 

 

 
